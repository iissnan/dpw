<!doctype html>



  


<html class="theme-next pisces use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  
    
      
    

    
  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Noto Serif:300,300italic,400,400italic,700,700italic|Cousine:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.6" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="DPW Working Notes" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.6" />






<meta name="description" content="前言JavaScript 是一种动态类型、基于原型的解释性语言，她拥有着强大而灵活的表达能力。而 Great power comes great responsibility，在没有类似静态编译语言的编译器协助的情况下，JavaScript 大型应用可能潜在着很大的风险。因此，AngularJS 团队认为为 JavaScript 构建的应用编写测试非常的重要，他们将 可测试性（testable）">
<meta property="og:type" content="website">
<meta property="og:title" content="DPW UI Unit Testing">
<meta property="og:url" content="http://dpw.iissnan.com/unit-testing/index.html">
<meta property="og:site_name" content="Vi's Working Notes @ RC">
<meta property="og:description" content="前言JavaScript 是一种动态类型、基于原型的解释性语言，她拥有着强大而灵活的表达能力。而 Great power comes great responsibility，在没有类似静态编译语言的编译器协助的情况下，JavaScript 大型应用可能潜在着很大的风险。因此，AngularJS 团队认为为 JavaScript 构建的应用编写测试非常的重要，他们将 可测试性（testable）">
<meta property="og:image" content="http://dpw.iissnan.com/uploads/webstorm-karma-configuration.png">
<meta property="og:updated_time" content="2016-08-31T04:33:27.119Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="DPW UI Unit Testing">
<meta name="twitter:description" content="前言JavaScript 是一种动态类型、基于原型的解释性语言，她拥有着强大而灵活的表达能力。而 Great power comes great responsibility，在没有类似静态编译语言的编译器协助的情况下，JavaScript 大型应用可能潜在着很大的风险。因此，AngularJS 团队认为为 JavaScript 构建的应用编写测试非常的重要，他们将 可测试性（testable）">
<meta name="twitter:image" content="http://dpw.iissnan.com/uploads/webstorm-karma-configuration.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"right","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>




  <title>
  

  
    DPW UI Unit Testing | Vi's Working Notes @ RC
  
</title>
</head>

<body lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-right  ">
    

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <h1 class="brand" style="opacity: 1;">DPW UI Unit Testing</h1>

  <div id="posts" class="posts-expand">
    
    
      <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>JavaScript 是一种动态类型、基于原型的解释性语言，她拥有着强大而灵活的表达能力。而 Great power comes great responsibility，在没有类似静态编译语言的编译器协助的情况下，JavaScript 大型应用可能潜在着很大的风险。因此，AngularJS 团队认为为 JavaScript 构建的应用编写测试非常的重要，他们将 <strong><em>可测试性（testable）</em></strong> 作为 AngularJS 框架一个非常显著的特性。</p>
<p>AngularJS 框架为测试提供了很多特性，这些特性使得给 AngularJS 应用编写测试相当地简单。但第一次接触时可能会觉得无从入手，而一旦理解之后就会明白测试在 AngularJS 应用中其实十分的直白并有迹可循。现在，我们应当从 “启动应用（刷新页面），并手动检查一切功能正常工作” 的模式切换到 “我有单元测试覆盖” 的模式，在此前提下，更多地关注业务逻辑、算法代码优化以及制作更为精美的 UI。</p>
<p><strong>Unit Testing 与 End-to-End Testing</strong></p>
<ul>
<li><strong>Unit Testing</strong><br>  单元测试用于直接调用代码的某个单元实体（比如 Directive，Contronller 等），并测试此功能单元实体。通常一个测试套件对应一个功能实体，测试套件由一个或多个测试用例构成。在测试用例内部，我们构造数据并调用代码，并断言代码的实际的输出符合我们的预期。</li>
<li><strong>End-to-End</strong><br>  E2E 测试模拟真实的用户，使用代码来模拟用户访问应用并做出某些操作（点击按钮、输入内容等）。举个简单的 E2E 测试例子：模拟用户访问应用首页，点击登录按钮，断言登陆成功时跳转到后台首页 <code>/dashboard</code>。目前在 DPW，E2E 测试主要由 Test Automation Team 负责。AngularJS 团队也提供了一个用于 E2E 测试的框架： <a href="http://www.protractortest.org" target="_blank" rel="external">Protractor</a>。</li>
</ul>
<h2 id="测试工具栈"><a href="#测试工具栈" class="headerlink" title="测试工具栈"></a>测试工具栈</h2><p>AngularJS 框架让编写测试变得简单，但为了让整个测试过程可便捷地反复地之行，我们还需要一套工具集让将测试的执行过程尽量地简化。这套工具集包括 <a href="https://karma-runner.github.io" target="_blank" rel="external">Karma</a>，<a href="https://mochajs.org" target="_blank" rel="external">Mocha</a>，<a href="http://chaijs.com" target="_blank" rel="external">Chai</a> 以及 <a href="http://sinonjs.org" target="_blank" rel="external">Sinon</a>。</p>
<h3 id="Karma"><a href="#Karma" class="headerlink" title="Karma"></a><a href="https://karma-runner.github.io" target="_blank" rel="external">Karma</a></h3><p>Karma 是 AngularJS 团队出品的测试运行工具（<strong><em>Test Runner</em></strong>），目标在于简化建立测试环境的工作量。Karma 的特性之一是可以将代码放置在真实的设备上运行，可以指定多个运行环境，例如同时在 Google Chrome，Firefox 和 IE 浏览器上运行；另外一个特性是其测试框架无关性，这意味这你可以选择熟悉的测试框架（Mocha，Jasmine 或者 Qunit）；最后，Karma 与 IDE （例如 WebStorm） 和 持续集成系统（Jenkins）都可以方便的结合使用。</p>
<h4 id="安装-Karma"><a href="#安装-Karma" class="headerlink" title="安装 Karma"></a>安装 Karma</h4><p>Karma 的运行环境是 <a href="https://nodejs.org" target="_blank" rel="external">Node.js</a>，Node.js 的版本要求在 0.10 之上。如果系统安装过 Node.js，即可在命令行中（项目目录下）运行以下命令来安装 karma 以及其命令行调用工具：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install --save-dev karma</div></pre></td></tr></table></figure>
<p>这条命令指定 Karma 作为项目的开发依赖包，之后我们可以通过以下命令来调用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ ./node_modules/karma/bin/karma start</div></pre></td></tr></table></figure>
<p>当需要多次使用时，通过调用 <code>node_modules</code> 目录下的文件会显得非常繁琐，我们可以安装 <code>karmar-cli</code> 来解决这个问题：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install -g karma-cli</div></pre></td></tr></table></figure>
<p><code>karma-cli</code> 提供了 <code>karma</code> 命令。执行 <code>karma</code> 命令将调用项目目录下的 <code>node_moules/karma</code> 来启动测试。</p>
<h4 id="配置-Karma"><a href="#配置-Karma" class="headerlink" title="配置 Karma"></a>配置 Karma</h4><p>各个项目的组织方式不同，为了兼容不同的项目，Karma 需要一个配置文件来告诉她关于项目的信息。这些配置包括：待测试的源码文件以及测试代码、采用的测试框架和断言库、测试环境（浏览器）等信息。我们可以使用 <code>karma init</code> 命令来启动交互式的配置过程。例如，创建 <code>developer site</code> 的配置文件 ：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">karam init developer.conf.js</div></pre></td></tr></table></figure>
<p>Karma 配置文件示例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">config</span>) </span>&#123;</div><div class="line">  config.set(&#123;</div><div class="line">    basePath: <span class="string">'./'</span>,</div><div class="line">    files: [<span class="string">'asserts/js/**/*.js'</span>],</div><div class="line">    frameworks: [<span class="string">'mocha'</span>, <span class="string">'chai'</span>, <span class="string">'sinon'</span>],</div><div class="line">    browsers: [<span class="string">'chrome'</span>],</div><div class="line">    reporters: [<span class="string">'mocha'</span>],</div><div class="line">    autoWatch: <span class="literal">true</span></div><div class="line">  &#125;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>关于更多配置的信息请参考 <a href="https://karma-runner.github.io/1.0/config/configuration-file.html" target="_blank" rel="external">Karma Configuration File</a>。</p>
<h3 id="Mocha"><a href="#Mocha" class="headerlink" title="Mocha"></a><a href="https://mochajs.org" target="_blank" rel="external">Mocha</a></h3><p>Mocha 测试框架诞生于 2011 年，是目前最流行的 JavaScript 测试框架之一，在 浏览器 和 Node 环境中都可以使用。一份简单的 Mocha 测试文件的例子如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> assert = <span class="built_in">require</span>(<span class="string">'assert'</span>);</div><div class="line"></div><div class="line">describe(<span class="string">'Array'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  it(<span class="string">'#indexOf'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    assert.equal(<span class="number">-1</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].indexOf(<span class="number">4</span>));</div><div class="line">  &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>在这个例子中，<code>describe</code> 函数用于描述一个 <strong>测试套件</strong>，第一个参数是套件的名称，第二参数是一个实际执行的函数。<code>it</code> 函数描述具体的 <strong>测试用例</strong>，表示一个单独的测试；第一个参数是用例的名称，第二个参数是一个实际执行的函数。</p>
<blockquote>
<p><strong>注</strong>： Mocha 基础知识可以参阅 <a href="http://www.ruanyifeng.com/blog/2015/12/a-mocha-tutorial-of-examples.html" target="_blank" rel="external">《测试框架 Mocha 实例教程》</a>。</p>
</blockquote>
<h3 id="Chai"><a href="#Chai" class="headerlink" title="Chai"></a><a href="http://chaijs.com" target="_blank" rel="external">Chai</a></h3><p><strong>断言</strong> 是指源码执行的结果与预期结果是否一致，如果不一直就抛出错误。由于 Mocha 并未内置断言功能，因此需要使用第三方断言库，我们使用的是 Chai。</p>
<p>Chai 是一个可应用于 浏览器 和 Node 环境的断言库，她提供了三种断言风格，即<code>Should</code>，<code>Expect</code> 以及 <code>Assert</code>。我们目前采用的是 <code>Expect</code> 风格，一个简单的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">it(<span class="string">'#indexOf'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  expect([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].indexOf(<span class="number">4</span>)).to.equal(<span class="number">-1</span>);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h3 id="Sinon"><a href="#Sinon" class="headerlink" title="Sinon"></a><a href="http://sinonjs.org/" target="_blank" rel="external">Sinon</a></h3><p> Sinon 是一个 JavaScript 测试中用于 Spy，Stub 和 Mock 库。简单来说，Sinon 可以为测试提供 “测试替身”，替换不确定的依赖从而使测试变得简单。Sinon 将所谓的 “测试替身” 分为 3 种类型：</p>
<ul>
<li>Spies：可以提供函数调用的信息，但不会改变函数的行为</li>
<li>Stubs：与 Spies 类似，但会完全替换掉目标函数。这使得我们可以用这个替身做任何想要的事情，例如返回特定的值。</li>
<li>Mocks：通过组合 Spies 和 Stubs，替换一个完整的对象。</li>
</ul>
<p>创建一个 Spy 的简单示例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> spy = sinon.spy()</div><div class="line"></div><div class="line"><span class="comment">// 可以像调用函数一样调用一个 spy</span></div><div class="line">spy(<span class="string">'Hello'</span>);</div><div class="line"></div><div class="line"><span class="comment">// 现在我们可以获取这次调用的信息</span></div><div class="line"><span class="built_in">console</span>.log(spy.firstCalls.args);</div></pre></td></tr></table></figure>
<p>另一种场景是我们需要将一个对象的某个函数替换成一个 spy：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> user = &#123;</div><div class="line">  setName: <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 为 SetName 方法创建一个 spy</span></div><div class="line"><span class="keyword">var</span> setNameSpy = sinon.spy(user, <span class="string">'setName'</span>);</div><div class="line"></div><div class="line"><span class="comment">// 现在开始，每次调用这个方法是，相关信息都会被记录</span></div><div class="line">user.setName(<span class="string">'Vi'</span>);</div><div class="line"></div><div class="line"><span class="comment">// 查看 Spy 获取到的信息</span></div><div class="line"><span class="built_in">console</span>.log(setNameSpy.callCount);</div><div class="line"></div><div class="line"><span class="comment">// 最后，移除 spy</span></div><div class="line">setNameSpy.restore()</div></pre></td></tr></table></figure>
<h2 id="编写测试之前"><a href="#编写测试之前" class="headerlink" title="编写测试之前"></a>编写测试之前</h2><p>在 DPW 项目中，所有测试相关的文件都存放于 <code>WEB/test</code> 目录下。第一次使用时需要安装测试的 NPM 依赖包：在 <code>WEB/test</code> 目录下执行 <code>npm install</code> 来安装所需的依赖。</p>
<p>当依赖安装完成之后，即可运行 <code>npm run developer</code> 来执行测试。在 Windows 平台上也可以使用 <code>desktop.bat</code> 批处理文件来启动测试。除此之外，也可以集合 WebStorm IDE 来启动测试（推荐的方式），WebStorm 测试的配置请看下图:</p>
<p><img alt="WebStorm Karma Configuration" class="full-image" src="/uploads/webstorm-karma-configuration.png"></p>
<h3 id="测试文件组织"><a href="#测试文件组织" class="headerlink" title="测试文件组织"></a>测试文件组织</h3><p>单元测试文件存放于 <code>WEB/test/unit</code> 目录下，测试脚本支持 ES5 以及 <a href="http://coffeescript.org/" target="_blank" rel="external">CoffeeScript</a>，文件命名采用 <code>name.spec.js</code> (或 <code>name.spec.coffee</code>）的形式，并与待测试的脚本名字关联（若待测试的脚本所包含的内容比较多，可以使用目录的形式，目录中每一个文件对应待测试脚本的一个功能点）。</p>
<h3 id="JavaScript-与-CoffeeScript"><a href="#JavaScript-与-CoffeeScript" class="headerlink" title="JavaScript 与 CoffeeScript"></a>JavaScript 与 CoffeeScript</h3><p>通常测试文件包含大多数的 <code>describe</code> 和 <code>it</code>，每一个块都比较简短，而 <code>describe</code> 和 <code>it</code> 都是接收 <code>string</code> 和 <code>function</code> 的形式，这将导致测试脚本包含大量的括号 <code>()</code> 和 花括号 <code>{}</code>。而 CoffeeScript 非常适合用于这种场景，因此为了更快速简洁地编写测试脚本，推荐使用 CoffeeScript 作为主要的编写语言（编写测试仅需要很少的 CoffeeScript 的知识）。我们可以来对比下使用 JavaScript 和 CoffeeScript 编写的测试文件之间的差异：</p>
<p>使用 JavaScript 编写，可以看到里面包含着大量的符号：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">describe(<span class="string">'Array'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  it(<span class="string">'#isArray'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    expect(<span class="built_in">Array</span>.isArray([<span class="number">1</span>, <span class="number">2</span>])).to.equal <span class="literal">true</span></div><div class="line">  &#125;);</div><div class="line">  it(<span class="string">'#filter'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> actual = [<span class="number">1</span>, <span class="number">2</span>].filter(<span class="function"><span class="keyword">function</span> (<span class="params">item</span>) </span>&#123;</div><div class="line">      <span class="keyword">return</span> item &gt; <span class="number">1</span>;</div><div class="line">    &#125;);</div><div class="line">    expect(actual).to.deep.equal [<span class="number">2</span>]</div><div class="line">  &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>同样的测试脚本使用 CoffeeScript 编写，代码显得十分整洁：</p>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">describe &apos;Array&apos;, -&gt;</div><div class="line">  it &apos;#isArray&apos;, -&gt;</div><div class="line">    expect(Array.isArray [1, 2]).to.equal true</div><div class="line"></div><div class="line">  it &apos;#filter&apos;, -&gt;</div><div class="line">    actual = [1, 2].filter -&gt; item &gt; 1</div><div class="line">    expect(actual).to.deep.equal [2]</div></pre></td></tr></table></figure>
<p>项目内部已经有许多使用 CoffeeScript 编写的测试脚本，你可以将他们作为参考。在此之前，你或许需要了解 CoffeeScript 最基本的几点知识：</p>
<ol>
<li>变量定义不需要 <code>var</code></li>
<li>函数定义使用 <code>-&gt;</code> 代替 <code>function</code> 关键字</li>
<li>函数调用时的括号时可以省略的</li>
</ol>
<h2 id="开始编写测试"><a href="#开始编写测试" class="headerlink" title="开始编写测试"></a>开始编写测试</h2><p>AngularJS 应用的单元测试有一个特性就是：在测试代码之前，我们需要手动引用代码所属的模块（module）以及获取代码中所使用的依赖（DI）。幸运的是，AngularJS 提供了方便的方法让我们处理上述两个过程。</p>
<h3 id="编写测试的-Pre-condition-（必读）"><a href="#编写测试的-Pre-condition-（必读）" class="headerlink" title="编写测试的 Pre-condition （必读）"></a>编写测试的 Pre-condition （必读）</h3><p>我们将在这个章节介绍：“如何引用 module” 以及 “依赖的注入”，所有的测试脚本都将使用到这部分介绍的内容，所以本节 的内容是 <strong>必读</strong> 的。</p>
<h4 id="Module-的引用"><a href="#Module-的引用" class="headerlink" title="Module 的引用"></a>Module 的引用</h4><p>AngularJS 以 module 来组织应用，因此在执行测试之前需要引用 module。为了引用 module，我们需要使用到 AngularJS 提供的一个称为 <a href="https://docs.angularjs.org/api/ngMock" target="_blank" rel="external">ngMock</a> 的测试辅助 Module，此模块提供的 <code>angular.mock.module</code> 方法用于引入 module(s)。此方法注册了一个快捷方法在 <code>window</code> 全局空间里即：<code>window.module</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">angular.mock.module(<span class="string">'moduleName'</span>);</div><div class="line"></div><div class="line"><span class="comment">// 或者 </span></div><div class="line"><span class="built_in">module</span>(<span class="string">'moduleName'</span>);</div></pre></td></tr></table></figure>
<p>当我们需要测试一个放在 <code>dpw.components</code> module 下的实体时，使用以下语句来引入 <code>dpw.components</code> module：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">beforeEach( <span class="built_in">module</span>(<span class="string">'dpw.components'</span>) );</div></pre></td></tr></table></figure>
<p><strong>注意：</strong> 模块的引入必须在 <code>angular.mock.inject</code> 之前调用。</p>
<h5 id="关于-angular-mock-module"><a href="#关于-angular-mock-module" class="headerlink" title="关于 angular.mock.module"></a>关于 <code>angular.mock.module</code></h5><p>此方法主要用于收集 modules，这些 modules 将用于在每个测试用例之前创建 <code>$injector</code> 对象（即 DI 处理对象）。在测试不同的时期调用此方法，其执行结果不同：</p>
<ol>
<li>在 <code>beforeEach</code> 里调用，返回一个 <code>workFn</code>。</li>
<li>在 <code>it</code> 里调用，执行 <code>workFn</code>。</li>
</ol>
<h4 id="依赖的注入"><a href="#依赖的注入" class="headerlink" title="依赖的注入"></a>依赖的注入</h4><p>AngularJS 应用在 <a href="https://docs.angularjs.org/guide/bootstrap" target="_blank" rel="external">bootstrap</a> 的过程中会自动创建一个 <code>$injector</code> 用于处理 DI。而在单元测试中，bootstrap 的过程并未被自动触发，也就说我们需要手动创建 <code>$injector</code>。</p>
<p>ngMock 提供了一个方法来处理依赖：<code>angular.mock.inject</code>。此方法与 <code>angular.mock.module</code> 相同，也在 <code>window</code> 全局空间下注册了一个快捷方法 <code>window.inject</code>。让我们先来看下如何使用 <code>inject</code> 方法注入依赖：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 声明一个局部变量</span></div><div class="line"><span class="keyword">var</span> $rootScope;</div><div class="line"></div><div class="line">beforeEach(inject(<span class="function"><span class="keyword">function</span> (<span class="params">_$rootScope_</span>) </span>&#123;</div><div class="line">  <span class="comment">// 当依赖注入后，将获取到的依赖存储在 $rootScope 局部变量中</span></div><div class="line">  <span class="comment">// _$rootScope_ 是一个特殊的写法</span></div><div class="line">  <span class="comment">// AngularJS 会自动去除前后的 _ 去获取正确的 service</span></div><div class="line">  $rootScope = _$rootScope_;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>上述例子中，我们定义里一个局部变量 <code>$rootScope</code>。在依赖注入之后，将获取到的依赖 <code>_$rootScope_</code> 存储在这个局部变量中。</p>
<h5 id="inject-的工作原理"><a href="#inject-的工作原理" class="headerlink" title="inject 的工作原理"></a>inject 的工作原理</h5><p><code>inject</code> 方法接收一个或多个函数（记为 <code>Fns</code>）作为参数，方法将调用 <code>angular.injector</code> 并使用 <code>angular.mock.module</code> 中配置的 modules（自动会添加上 ng, ngMock）来创建一个 <code>$injector</code>，然后调用 <code>$injector.invoke</code> 方法解析 <code>Fns</code> 中所需的依赖。</p>
<h5 id="inject-的最佳实践"><a href="#inject-的最佳实践" class="headerlink" title="inject 的最佳实践"></a>inject 的最佳实践</h5><p>例子中出现了前后双下划线（ <code>_$rootScope_</code> ），这个是为了方便我们命名局部变量。AngularJS 在内部依赖的时候会自动将前后的下划线去掉，从而获取到正确的依赖。请参阅 <a href="https://docs.angularjs.org/api/ngMock/function/angular.mock.inject#resolving-references-underscore-wrapping-" target="_blank" rel="external">官方文档的说明</a>。如果，这种方式看起来比较别扭或者需要引用较多的依赖时，我们可以只获取 <code>$injector</code> 依赖，然后通过这个对象来获取所需的其它依赖：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> $rootScope;</div><div class="line"></div><div class="line">beforeEach(inject(<span class="function"><span class="keyword">function</span> (<span class="params">$injector</span>) </span>&#123;</div><div class="line">  $rootScope = $injector.get(<span class="string">'$rootScope'</span>);</div><div class="line">  $location = $injector.get(<span class="string">'$location'</span>);</div><div class="line">  <span class="comment">// 等等</span></div><div class="line">&#125;));</div></pre></td></tr></table></figure>
<h5 id="Filters-的注入"><a href="#Filters-的注入" class="headerlink" title="Filters 的注入"></a>Filters 的注入</h5><p>Filter 的注入有点特殊，因为注入的时候，我们需要在 filter 的名字后面加上 <code>Filter</code>。举个例子，假设有一个名为 <code>foo</code> 的 filter，他的注入形式如下（注意 <code>inject</code> 函数的参数名称）：</p>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">describe <span class="string">'Filter: foo'</span>, <span class="function">-&gt;</span></div><div class="line">  foo = <span class="literal">null</span></div><div class="line"></div><div class="line">  beforeEach <span class="built_in">module</span> <span class="string">'bar'</span></div><div class="line">  beforeEach inject (fooFilter) -&gt;</div><div class="line">    foo = fooFilter</div><div class="line"></div><div class="line">  it <span class="string">'foo is always foo'</span>, <span class="function">-&gt;</span></div><div class="line">    expect(foo <span class="string">'anything'</span>).to.equal <span class="string">'foo'</span></div></pre></td></tr></table></figure>
<h5 id="关于-angular-mock-inject"><a href="#关于-angular-mock-inject" class="headerlink" title="关于 angular.mock.inject"></a>关于 <code>angular.mock.inject</code></h5><p>在 <code>beforeEach</code> 调用 <code>inject</code> 时返回一个函数（<code>fn</code>）。每一个测试用例执行前，<code>fn</code> 都会被执行并创建 <code>$injector</code>，传递给 <code>inject</code> 的函数将会被 <code>$injector.invoke</code> 调用，依赖便在此时注入；若在测试用例内部调用 <code>inject</code>，<code>fn</code> 将会被直接执行（<code>$injector</code> 已存在），依赖同样在此处理。</p>
<h3 id="让我们开始吧"><a href="#让我们开始吧" class="headerlink" title="让我们开始吧"></a>让我们开始吧</h3><p>到目前为止，我们了解了编写单元测试所需要的一些前置条件的知识。接下来，就让我们来针对 AngularJS 的不同实体（Service，Filter，Directive，Controller）说明测试用例的编写方法。</p>
<p><strong>注意：</strong> 以下示例测试代码将全部使用 CoffeeScript 编写。</p>
<h3 id="测试-Services"><a href="#测试-Services" class="headerlink" title="测试 Services"></a>测试 Services</h3><p>Services 与 Filters 是最为容易的测试部分，因此我们先从测试 Services 开始。测试一个 service 之前，我们需要了解这个 service 属于哪个 module 并引入此 module；而后通过依赖注入来获取此 service。</p>
<p>以 <code>helpers</code> 为例，其位于 <code>dpw.services</code> module 里，定义如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">angular.module(<span class="string">'dpw.services'</span>).factory(<span class="string">'helpers'</span>, [<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> &#123; foo: <span class="string">'bar'</span> &#125;;</div><div class="line">&#125;]);</div></pre></td></tr></table></figure>
<p>对应的测试脚本（<code>helpers.spec.coffee</code>）如下：</p>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">describe <span class="string">'Core Services'</span>, <span class="function">-&gt;</span></div><div class="line">  describe <span class="string">'helpers'</span>, <span class="function">-&gt;</span></div><div class="line">    <span class="comment"># 定义局部变量</span></div><div class="line">    helpers = <span class="literal">null</span></div><div class="line"></div><div class="line">    <span class="comment"># 引用 module</span></div><div class="line">    beforeEach(<span class="built_in">module</span> <span class="string">'dpw.services'</span>)</div><div class="line"></div><div class="line">    <span class="comment"># 获取 helpers</span></div><div class="line">    beforeEach inject ($injector) -&gt; </div><div class="line">      helpers = $injector.get <span class="string">'helpers'</span></div><div class="line"></div><div class="line">    <span class="comment"># 测试实例属性 foo</span></div><div class="line">    it <span class="string">'#foo'</span>, <span class="function">-&gt;</span></div><div class="line">      expect(helpers.foo).to.equal <span class="string">'bar'</span></div></pre></td></tr></table></figure>
<h3 id="测试-Filters"><a href="#测试-Filters" class="headerlink" title="测试 Filters"></a>测试 Filters</h3><p>Filters 的测试与 Service 类似，先引用 module，而后注入依赖。我们直接看例子：</p>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">describe <span class="string">'ngFilters#XSRF_Protect'</span>, <span class="function">-&gt;</span></div><div class="line">  XSRFProtect = <span class="literal">null</span></div><div class="line">  $cookies = <span class="literal">null</span></div><div class="line"></div><div class="line">  beforeEach(<span class="built_in">module</span> <span class="string">'dpw.common'</span>)</div><div class="line"></div><div class="line">  beforeEach inject (XSRFProtectFilter, _$cookies_) -&gt;</div><div class="line">    XSRFProtect = XSRFProtectFilter</div><div class="line">    $cookies = _$cookies_</div><div class="line">  </div><div class="line">  afterEach -&gt;</div><div class="line">    $cookies.remove(<span class="string">'XSRF-TOKEN'</span>)</div><div class="line"></div><div class="line">  it <span class="string">'Should return input if input is not a string'</span>, <span class="function">-&gt;</span></div><div class="line">    expect(XSRFProtect <span class="literal">undefined</span>).to.be.<span class="literal">undefined</span></div><div class="line"></div><div class="line">  it <span class="string">'Should return input if XSRF-TOKEN cookie is not exist'</span>, <span class="function">-&gt;</span></div><div class="line">    expect(XSRFProtect <span class="string">'foo'</span>).to.equal <span class="string">'foo'</span></div><div class="line"></div><div class="line">  it <span class="string">'Should add token to the input'</span>, <span class="function">-&gt;</span></div><div class="line">    $cookies.put <span class="string">'XSRF-TOKEN'</span>, <span class="string">'bar'</span></div><div class="line">    expect(XSRFProtect <span class="string">'/api/example'</span>).to.equal <span class="string">'/api/example?sctk=bar'</span></div></pre></td></tr></table></figure>
<h3 id="测试-Controllers"><a href="#测试-Controllers" class="headerlink" title="测试 Controllers"></a>测试 Controllers</h3><p>Controllers 的测试比 Services / Filters 的测试多加了一步，就是我们需要使用 <code>$controller</code> 去创建一个 Controller 的实例。在实例化 Controller 的过程，可能需要使用 <code>$rootScope</code> 来创建一个新的 scope；但若在 Controller 的内部没有使用到例如 <code>$watch</code>, <code>$apply</code> 等 scope 上的函数，使用一个对象字面量做为 scope 也可以。</p>
<p>我们先来看一下一个 Controller 测试代码的基本结构：</p>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">describe <span class="string">'DAG: Something Controller'</span>, <span class="function">-&gt;</span></div><div class="line">  $rootScope  = <span class="literal">null</span></div><div class="line">  $controller = <span class="literal">null</span></div><div class="line">  </div><div class="line"><span class="comment"># Someghint Controller 位于 `DAG.main` Module 里  </span></div><div class="line">beforeEach <span class="built_in">module</span> <span class="string">'DAG.main'</span>  </div><div class="line">beforeEach inject ($injector) -&gt;</div><div class="line">  $rootScope  = $injector.get <span class="string">'$rootScope'</span></div><div class="line">  $controller = $injector.get <span class="string">'$controller'</span></div><div class="line">  </div><div class="line">describe <span class="string">'Something#foo'</span>, <span class="function">-&gt;</span></div><div class="line">  <span class="comment"># 实例化一个 Something 的实例</span></div><div class="line">  <span class="comment"># $controller 接收两个参数：</span></div><div class="line">  <span class="comment">#   &#123;String&#125; - Controller 的名称</span></div><div class="line">  <span class="comment">#   &#123;Object&#125; - Local 数据，通常包含的是 $scope </span></div><div class="line">  $something = $controller <span class="string">'Something'</span>, &#123;$scope: $rootScope.$<span class="keyword">new</span>() &#125;</div><div class="line">  </div><div class="line">  expect($something.foo).to.equal <span class="string">'foo'</span></div></pre></td></tr></table></figure>
<h4 id="Mock-异步请求"><a href="#Mock-异步请求" class="headerlink" title="Mock 异步请求"></a>Mock 异步请求</h4><p>在 Controller 内部极有可能使用 <code>api</code> 这个 service 发起异步请求。当测试一个包含有异步请求的 Controller 时，我们通常希望可以 Mock 掉请求。在 AngularJS 中，我们可以使用被 ngMock 提供的 <code>$httpBackend</code> 来实现。</p>
<p>绝大多数情况下，我们将使用 <code>$httpBackend.when</code> 方法来拦截请求已经伪造返回数据。<code>when</code> 函数接收两个参数，第一个为请求的 HTTP Method，第二个是请求的地址，并返回一个 <code>requestHandler</code> 对象；接着，我们可以在这个 <code>requestHandler</code> 上调用 <code>response</code> 方法，响应请求并返回结果。例如：</p>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$httpBackend.when(&apos;GET&apos;, &apos;/api/users&apos;).response 200, &#123;&#125;</div></pre></td></tr></table></figure>
<p>在 ngMock 修改之前的 <code>$httpBackend</code> 会等待请求完成，然后返回结果给发起请求者，这个过程是异步的（因为各个请求的响应时间可能不同）。由于编写这种针对异步的测试代码较为繁琐，因此 ngMock 过的 <code>$httpBackend</code> 提供了一个称为 <code>flush</code> 的方法，这个方法响应请求（表示请求已完成）。</p>
<p>也就是说，当你使用 <code>$http</code> 发起一个异步请求后，你必须使用 <code>$httpBackend.flush</code> 方法。一个简单的例子如下：</p>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">beforeEach -&gt;</div><div class="line">  $httpBackend.when(&apos;GET&apos;, &apos;/api/user&apos;)  .response 200, &#123;name: &apos;Vi&apos;&#125;</div><div class="line">  </div><div class="line">describe &apos;DAG: Somegthing Controller&apos;, -&gt;  </div><div class="line">  it &apos;#foo&apos;, -&gt;</div><div class="line">    # Conteroller 内部有发起 API 请求</div><div class="line">    $something = $controller &apos;Something&apos;, &#123;$scope: $rootScope.$new()&#125;</div><div class="line">    </div><div class="line">    # 响应请求</div><div class="line">    $httpBackend.flush()</div><div class="line">    </div><div class="line">    expect($something.loaded).to.be.true</div></pre></td></tr></table></figure>
<p>需要注意的是，有请求发生时，我们都必须使用 <code>flush</code> 方法来响应。我们需要使用 <code>$httpBackend</code> 的两个方法来确保请求都有被捕获并响应：</p>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">afterEach -&gt;</div><div class="line">  $httpBackend.verifyNoOutstandingExpectation()</div><div class="line">  $httpBackend.verifyNoOutstandingRequest()</div></pre></td></tr></table></figure>
<h3 id="测试-Directives"><a href="#测试-Directives" class="headerlink" title="测试 Directives"></a>测试 Directives</h3><p>Directives 的测试实际上也非常的简单。引用 module 和 依赖注入这两个前置步骤依然需要，另外一个前置条件是 <strong>模板的处理</strong>。</p>
<h4 id="Directive-的模板注入"><a href="#Directive-的模板注入" class="headerlink" title="Directive 的模板注入"></a>Directive 的模板注入</h4><p>在当前的项目中，我们将所有的模板都放置在一个 <code>_temlates.html</code> 文件中，然后直接作为页面内容注入到页面上去，但在测试中并未注入这个文件的内容到页面上。</p>
<p>为了解决这个问题，我加了一个 Karma 的 Pre-processor，用于获取 <code>_templates.html</code> 中定义的模板。这个 Pre-processor 会将所有的模板放置到 <code>window.__templates__</code> 对象中，因此测试的时候，我们需要使用遍历这个对象，并使用 <code>$templateCache</code> 注册模板：</p>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">beforeEach inject ($injector) -&gt;</div><div class="line">  $templateCache = $injector.get <span class="string">'$templateCache'</span></div><div class="line"></div><div class="line">  <span class="comment"># Get all templates</span></div><div class="line">  <span class="keyword">for</span> id, template <span class="keyword">of</span> <span class="built_in">window</span>.__templates__</div><div class="line">    $templateCache.put(id, template)</div></pre></td></tr></table></figure>
<h4 id="Directive-的使用与数据传递"><a href="#Directive-的使用与数据传递" class="headerlink" title="Directive 的使用与数据传递"></a>Directive 的使用与数据传递</h4><p>接下来，我们需要使用 <code>$compile</code> 去编译待测试的 directive，得到一个 <code>link 函数</code>；紧接着构造一个 outerScope，并将 outerScope 作为 <code>link 函数</code> 的参数，完成 directive 模板与 outerScope 提供的数据进行绑定。Directive 所需要的数据，我们可以通过 outerScope 传递过去。</p>
<p>需要注意的是，<code>link 函数</code> 执行完成后，在下一次 digest 执行之前，数据并不会更新。在应用里 AngularJS 会自动更新，但在测试里不会，因此我们要自己调用 <code>$digest</code>。</p>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">describe <span class="string">'Direcive: dpw-checkbox'</span>, <span class="function">-&gt;</span></div><div class="line">  $rootScope = <span class="literal">null</span></div><div class="line">  $compile   = <span class="literal">null</span></div><div class="line"></div><div class="line">  beforeEach(<span class="built_in">module</span> <span class="string">'dpw.common'</span>)</div><div class="line">  beforeEach(inject ($injector) -&gt;</div><div class="line">    $rootScope = $injector.get <span class="string">'$rootScope'</span></div><div class="line">    $compile   = $injector.get <span class="string">'$compile'</span></div><div class="line">  )</div><div class="line"></div><div class="line">  it <span class="string">'model'</span>, <span class="function">-&gt;</span></div><div class="line">    <span class="comment"># 创建 Parent Scope</span></div><div class="line">    outerScope = $rootScope.$<span class="keyword">new</span>()</div><div class="line">    outerScope.isChecked = <span class="literal">true</span></div><div class="line"></div><div class="line">    element = $compile(<span class="string">'&lt;dpw-check model="isChecked"&gt;&lt;/dpw-check&gt;'</span>)(outerScope)</div><div class="line"></div><div class="line">    <span class="comment"># 触发 digest，更新数据</span></div><div class="line">    outerScope.$digest()</div></pre></td></tr></table></figure>
<h4 id="Directive-的数据断言"><a href="#Directive-的数据断言" class="headerlink" title="Directive 的数据断言"></a>Directive 的数据断言</h4><p><code>dpw-checkbox</code> 是将数据绑定在一个 isolate 的 scope，因此我们需要获取到这个 innerScope，然后断言 scope 里各个属性的值。</p>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">it <span class="string">'model'</span>, <span class="function">-&gt;</span></div><div class="line">  <span class="comment"># 这里省略获取 element 的步骤</span></div><div class="line">  innerScope = element.isolateScope()</div><div class="line"></div><div class="line">  expect(innerScope.model).to.be.<span class="literal">true</span></div></pre></td></tr></table></figure>
<p>更多时候，我们是将数据直接绑定到 directive 的 controller 上，此时我们可以通过 <code>element.controller()</code> 方法获取 controller。例如：</p>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">it <span class="string">'model'</span>, <span class="function">-&gt;</span></div><div class="line">  <span class="comment"># 这里省略获取 element 的步骤</span></div><div class="line">  ctrl = element.controller <span class="string">'directiveName'</span></div><div class="line"></div><div class="line">  <span class="comment"># 调用 controller 的 updateState 方法</span></div><div class="line">  ctrl.updateState state</div><div class="line"></div><div class="line">  expect(ctrl.state).to.equal <span class="string">'something'</span></div></pre></td></tr></table></figure>
<h4 id="Directive-的子元素断言"><a href="#Directive-的子元素断言" class="headerlink" title="Directive 的子元素断言"></a>Directive 的子元素断言</h4><p>除了通过 compile 后的 element 获取 scope 和 controller，我们同样可以获取到 element 的子元素。然后检查子元素的各种状态。</p>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">describe &apos;button&apos;, -&gt;</div><div class="line">  element = null</div><div class="line"></div><div class="line">  beforeEach -&gt;</div><div class="line">    element = $compile(&apos;...&apos;)(outerScope)</div><div class="line"></div><div class="line">  it &apos;should has a button&apos;, -&gt;</div><div class="line">    $button = element.find &apos;#buttonId&apos;</div><div class="line"></div><div class="line">    expect($button.length).to.equal 1</div><div class="line"></div><div class="line">  it &apos;should handle button click event&apos;, -&gt;</div><div class="line">    # 使用 trigger 触发 button 的 click 事件</div><div class="line">    $button.trigger &apos;click&apos;</div><div class="line"></div><div class="line">    outerScope.$digest()</div><div class="line"></div><div class="line">    expect(...).to.equal &apos;...&apos;</div></pre></td></tr></table></figure>
<h4 id="input-元素测试"><a href="#input-元素测试" class="headerlink" title="input 元素测试"></a>input 元素测试</h4><p>首先，input 元素的 change 事件触发会比较特殊一点。如果单纯地通过 jQuery 的 <code>val()</code> 函数更改 input 值，并不会触发 input 的 change 事件，必须结合使用 <code>trigger</code> 函数：</p>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">it <span class="string">'input test'</span>, <span class="function">-&gt;</span></div><div class="line">  <span class="comment"># element = ...</span></div><div class="line">  $inputElement.val(<span class="string">'foo'</span>).trigger <span class="string">'input'</span></div><div class="line">  outerScope.$digest();</div><div class="line"></div><div class="line">  <span class="comment"># expect</span></div></pre></td></tr></table></figure>
<p>如果 input 使用了 <code>ngModel</code>，并且使用了 <a href="https://docs.angularjs.org/api/ng/directive/ngModelOptions" target="_blank" rel="external">ngModelOptions</a> 的 <code>debounce</code> 时，我们需要借助 <code>$timeout.flush()</code> 来清除 debounce 的等待时间：</p>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">it <span class="string">'input test'</span>, <span class="function">-&gt;</span></div><div class="line">  <span class="comment"># element = ...</span></div><div class="line">  $inputElement.val(<span class="string">'foo'</span>).trigger <span class="string">'input'</span></div><div class="line">  $timeout.flush()</div><div class="line"></div><div class="line">  <span class="comment"># expect</span></div></pre></td></tr></table></figure>
<p>实际上，任何有使用 <code>$timeout</code> 的地方我们都可使用 <code>$timeout.flush()</code> 来清除等待时间，从而让测试变成同步执行。</p>
<h3 id="测试-Components"><a href="#测试-Components" class="headerlink" title="测试 Components"></a>测试 Components</h3><p>Component 的测试基本与 Directive 类似：引用 Module、依赖注入、获取模板以及使用 Component（同样是 $compile）。实际上，在 Angular 1.x 中 Component 仅仅是 Directive 的一层封装。</p>
<p>Component 倾向于抛弃 scope （还是可以使用），而使用 controller代替。因此为了测试的方便，ngMock 提供了 <code>$componentController</code> 方法，用于实例化一个 component 的 controller，而不用通过 $compile component 后去获取。</p>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">describe <span class="string">'Core Components'</span>, <span class="function">-&gt;</span></div><div class="line">  describle <span class="string">'some-component'</span>, <span class="function">-&gt;</span></div><div class="line">    $componentController = <span class="literal">null</span></div><div class="line"></div><div class="line">    beforeEach(<span class="built_in">module</span> <span class="string">'someModule'</span>)</div><div class="line">    beforeEach(inject ($injector) -&gt;</div><div class="line">      $componentController = $injector.get <span class="string">'$componentController'</span></div><div class="line">    )</div><div class="line"></div><div class="line">    it <span class="string">'Component Controller Instance'</span>, <span class="function">-&gt;</span></div><div class="line">      $ctrl = $componentController <span class="string">'someComponent'</span></div><div class="line">      $ctrl.onSearch <span class="string">'query'</span></div><div class="line">      expect($ctrl.foo).equal <span class="string">'bar'</span></div></pre></td></tr></table></figure>
<p>除了这点以外，Component 的测试与 Directive 几乎相同。</p>
<hr>
<h2 id="修订版本"><a href="#修订版本" class="headerlink" title="修订版本"></a>修订版本</h2><table>
<thead>
<tr>
<th>版本</th>
<th>日期</th>
<th>作者</th>
<th>修订信息</th>
</tr>
</thead>
<tbody>
<tr>
<td>1.0</td>
<td>2016-08-08</td>
<td>Vi</td>
<td>Initialization</td>
</tr>
<tr>
<td>1.1</td>
<td>2016-08-18</td>
<td>Vi</td>
<td>First review</td>
</tr>
</tbody>
</table>

    
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner affix">
      <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
        <p class="site-overview">文档目录</p>
        <div class="post-toc">
          <ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#前言"><span class="nav-text">前言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#测试工具栈"><span class="nav-text">测试工具栈</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Karma"><span class="nav-text">Karma</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#安装-Karma"><span class="nav-text">安装 Karma</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#配置-Karma"><span class="nav-text">配置 Karma</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Mocha"><span class="nav-text">Mocha</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Chai"><span class="nav-text">Chai</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Sinon"><span class="nav-text">Sinon</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#编写测试之前"><span class="nav-text">编写测试之前</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#测试文件组织"><span class="nav-text">测试文件组织</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JavaScript-与-CoffeeScript"><span class="nav-text">JavaScript 与 CoffeeScript</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#开始编写测试"><span class="nav-text">开始编写测试</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#编写测试的-Pre-condition-（必读）"><span class="nav-text">编写测试的 Pre-condition （必读）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Module-的引用"><span class="nav-text">Module 的引用</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#关于-angular-mock-module"><span class="nav-text">关于 angular.mock.module</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#依赖的注入"><span class="nav-text">依赖的注入</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#inject-的工作原理"><span class="nav-text">inject 的工作原理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#inject-的最佳实践"><span class="nav-text">inject 的最佳实践</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Filters-的注入"><span class="nav-text">Filters 的注入</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#关于-angular-mock-inject"><span class="nav-text">关于 angular.mock.inject</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#让我们开始吧"><span class="nav-text">让我们开始吧</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#测试-Services"><span class="nav-text">测试 Services</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#测试-Filters"><span class="nav-text">测试 Filters</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#测试-Controllers"><span class="nav-text">测试 Controllers</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Mock-异步请求"><span class="nav-text">Mock 异步请求</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#测试-Directives"><span class="nav-text">测试 Directives</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Directive-的模板注入"><span class="nav-text">Directive 的模板注入</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Directive-的使用与数据传递"><span class="nav-text">Directive 的使用与数据传递</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Directive-的数据断言"><span class="nav-text">Directive 的数据断言</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Directive-的子元素断言"><span class="nav-text">Directive 的子元素断言</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#input-元素测试"><span class="nav-text">input 元素测试</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#测试-Components"><span class="nav-text">测试 Components</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#修订版本"><span class="nav-text">修订版本</span></a></li></ol>
        </div>
      </section>
    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; <span itemprop="copyrightYear">2016</span>
  &nbsp; - &nbsp;
  <span class="author" itemprop="copyrightHolder">Vi</span>
  <span class="with-love">
    <i class="fa fa-truck fa-fw"></i>
    <i class="fa fa-github-alt fa-fw"></i>
  </span>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.6"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.6"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.6"></script>

  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.6"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.6"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.6"></script>



  <script>
    $(document).ready(function () {
      var tocSelector = '.post-toc';
      var $tocElement = $(tocSelector);
      var activeCurrentSelector = '.active-current';

      $tocElement
        .on('activate.bs.scrollspy', function () {
          var $currentActiveElement = $(tocSelector + ' .active').last();

          removeCurrentActiveClass();
          $currentActiveElement.addClass('active-current');
        })
        .on('clear.bs.scrollspy', removeCurrentActiveClass);

      $('body').scrollspy({ target: tocSelector });

      function removeCurrentActiveClass () {
        $(tocSelector + ' ' + activeCurrentSelector)
          .removeClass(activeCurrentSelector.substring(1));
      }
    });
  </script>

  



  




  
  

  

  

  
  


</body>
</html>
