<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Recollection | DPW UI Unit Testing</title>
    <meta name="description" content="Working Notes @RC">
    <link rel="shortcut icon" type="image/x-icon" href="favicon.ico">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=IBM+Plex+Mono|IBM+Plex+Sans">
    
    <link rel="preload" href="/assets/css/8.styles.776315af.css" as="style"><link rel="preload" href="/assets/js/app.6a6bb248.js" as="script"><link rel="preload" href="/assets/js/4.6b933240.js" as="script"><link rel="prefetch" href="/assets/js/0.7452da9d.js"><link rel="prefetch" href="/assets/js/1.1ae350a5.js"><link rel="prefetch" href="/assets/js/2.94156d0c.js"><link rel="prefetch" href="/assets/js/3.8a4e893c.js"><link rel="prefetch" href="/assets/js/5.b0f5851e.js"><link rel="prefetch" href="/assets/js/6.5dc494d2.js"><link rel="prefetch" href="/assets/js/7.42ce12cc.js">
    <link rel="stylesheet" href="/assets/css/8.styles.776315af.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div><a href="/" class="home-link router-link-active"><!----><span class="site-name">
      Recollection
    </span></a><div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""><!----></div><nav class="nav-links can-hide"><div class="nav-item"><a href="/dpw-unit-testing/" class="nav-link router-link-exact-active router-link-active">DPW UI 单元测试</a></div><div class="nav-item"><a href="/rc-components-abbreviations/" class="nav-link">DPW 相关组件简称</a></div><!----></nav></div></header><div class="sidebar-mask"></div><div class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/dpw-unit-testing/" class="nav-link router-link-exact-active router-link-active">DPW UI 单元测试</a></div><div class="nav-item"><a href="/rc-components-abbreviations/" class="nav-link">DPW 相关组件简称</a></div><!----></nav><ul class="sidebar-links"><li><div class="sidebar-group first"><p class="sidebar-heading open"><span>DPW UI Unit Testing</span><!----></p><ul class="sidebar-group-items"><li><a href="/dpw-unit-testing/#前言" class="sidebar-link">前言</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/dpw-unit-testing/#测试工具栈" class="sidebar-link">测试工具栈</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/dpw-unit-testing/#karma" class="sidebar-link">[Karma](https://karma-runner.github.io)</a></li><li class="sidebar-sub-header"><a href="/dpw-unit-testing/#mocha" class="sidebar-link">[Mocha](https://mochajs.org)</a></li><li class="sidebar-sub-header"><a href="/dpw-unit-testing/#chai" class="sidebar-link">[Chai](http://chaijs.com)</a></li><li class="sidebar-sub-header"><a href="/dpw-unit-testing/#sinon" class="sidebar-link">[Sinon](http://sinonjs.org/)</a></li></ul></li><li><a href="/dpw-unit-testing/#编写测试之前" class="sidebar-link">编写测试之前</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/dpw-unit-testing/#测试文件组织" class="sidebar-link">测试文件组织</a></li><li class="sidebar-sub-header"><a href="/dpw-unit-testing/#javascript-与-coffeescript" class="sidebar-link">JavaScript 与 CoffeeScript</a></li></ul></li><li><a href="/dpw-unit-testing/#开始编写测试" class="sidebar-link">开始编写测试</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/dpw-unit-testing/#编写测试的-pre-condition-（必读）" class="sidebar-link">编写测试的 Pre-condition （必读）</a></li><li class="sidebar-sub-header"><a href="/dpw-unit-testing/#让我们开始吧" class="sidebar-link">让我们开始吧</a></li><li class="sidebar-sub-header"><a href="/dpw-unit-testing/#测试-services" class="sidebar-link">测试 Services</a></li><li class="sidebar-sub-header"><a href="/dpw-unit-testing/#测试-filters" class="sidebar-link">测试 Filters</a></li><li class="sidebar-sub-header"><a href="/dpw-unit-testing/#测试-controllers" class="sidebar-link">测试 Controllers</a></li><li class="sidebar-sub-header"><a href="/dpw-unit-testing/#测试-directives" class="sidebar-link">测试 Directives</a></li><li class="sidebar-sub-header"><a href="/dpw-unit-testing/#测试-components" class="sidebar-link">测试 Components</a></li></ul></li><li><a href="/dpw-unit-testing/#修订版本" class="sidebar-link">修订版本</a><ul class="sidebar-sub-headers"></ul></li></ul></div></li></ul></div><div class="page"><div class="content"><h2 id="前言"><a href="#前言" aria-hidden="true" class="header-anchor">#</a> 前言</h2><p>JavaScript 是一种动态类型、基于原型的解释性语言，她拥有着强大而灵活的表达能力。而 Great power comes great responsibility，在没有类似静态编译语言的编译器协助的情况下，JavaScript 大型应用可能潜在着很大的风险。因此，AngularJS 团队认为为 JavaScript 构建的应用编写测试非常的重要，他们将 <em><strong>可测试性（testable）</strong></em> 作为 AngularJS 框架一个非常显著的特性。</p><p>AngularJS 框架为测试提供了很多特性，这些特性使得给 AngularJS 应用编写测试相当地简单。但第一次接触时可能会觉得无从入手，而一旦理解之后就会明白测试在 AngularJS 应用中其实十分的直白并有迹可循。</p><p>现在，让我们从 “启动应用（刷新页面），并手动检查一切功能正常工作” 的模式切换到 “有元测试覆盖心里更有底” 的模式吧。在此前提下，更多地关注业务逻辑、算法代码优化以及制作更为精美的 UI。</p><p><strong>Unit Testing 与 End-to-End Testing</strong></p><ul><li><strong>Unit Testing</strong>
单元测试用于直接调用代码的某个单元实体（比如 Directive，Contronller 等），并测试此功能单元实体。通常一个测试套件对应一个功能实体，测试套件由一个或多个测试用例构成。在测试用例内部，我们构造数据并调用代码，并断言代码的实际的输出符合我们的预期。</li><li><strong>End-to-End</strong>
E2E 测试模拟真实的用户，使用代码来模拟用户访问应用并做出某些操作（点击按钮、输入内容等）。举个简单的 E2E 测试例子：模拟用户访问应用首页，点击登录按钮，断言登陆成功时跳转到后台首页 <code>/dashboard</code>。目前在 DPW，E2E 测试主要由 Test Automation Team 负责。AngularJS 团队也提供了一个用于 E2E 测试的框架： <a href="http://www.protractortest.org" target="_blank" rel="noopener noreferrer">Protractor</a>。</li></ul><h2 id="测试工具栈"><a href="#测试工具栈" aria-hidden="true" class="header-anchor">#</a> 测试工具栈</h2><p>AngularJS 框架让编写测试变得简单，但为了让整个测试过程可便捷地反复地之行，我们还需要一套工具集让将测试的执行过程尽量地简化。这套工具集包括 <a href="https://karma-runner.github.io" target="_blank" rel="noopener noreferrer">Karma</a>，<a href="https://mochajs.org" target="_blank" rel="noopener noreferrer">Mocha</a>，<a href="http://chaijs.com" target="_blank" rel="noopener noreferrer">Chai</a> 以及 <a href="http://sinonjs.org" target="_blank" rel="noopener noreferrer">Sinon</a>。</p><h3 id="karma"><a href="#karma" aria-hidden="true" class="header-anchor">#</a><a href="https://karma-runner.github.io" target="_blank" rel="noopener noreferrer">Karma</a></h3><p>Karma 是 AngularJS 团队出品的测试运行工具（<em><strong>Test Runner</strong></em>），目标在于简化建立测试环境的工作量。Karma 的特性之一是可以将代码放置在真实的设备上运行，可以指定多个运行环境，例如同时在 Google Chrome，Firefox 和 IE 浏览器上运行；另外一个特性是其测试框架无关性，这意味这你可以选择熟悉的测试框架（Mocha，Jasmine 或者 Qunit）；最后，Karma 与 IDE （例如 WebStorm） 和 持续集成系统（Jenkins）都可以方便的结合使用。</p><h4 id="安装-karma"><a href="#安装-karma" aria-hidden="true" class="header-anchor">#</a> 安装 Karma</h4><p>Karma 的运行环境是 <a href="https://nodejs.org" target="_blank" rel="noopener noreferrer">Node.js</a>，Node.js 的版本要求在 0.10 之上。如果系统安装过 Node.js，即可在命令行中（项目目录下）运行以下命令来安装 karma 以及其命令行调用工具：</p><pre class="language-text"><code>$ npm install --save-dev karma
</code></pre><p>这条命令指定 Karma 作为项目的开发依赖包，之后我们可以通过以下命令来调用：</p><pre class="language-text"><code>$ ./node_modules/karma/bin/karma start
</code></pre><p>当需要多次使用时，通过调用 <code>node_modules</code> 目录下的文件会显得非常繁琐，我们可以安装 <code>karmar-cli</code> 来解决这个问题：</p><pre class="language-text"><code>$ npm install -g karma-cli
</code></pre><p><code>karma-cli</code> 提供了 <code>karma</code> 命令。执行 <code>karma</code> 命令将调用项目目录下的 <code>node_moules/karma</code> 来启动测试。</p><h4 id="配置-karma"><a href="#配置-karma" aria-hidden="true" class="header-anchor">#</a> 配置 Karma</h4><p>各个项目的组织方式不同，为了兼容不同的项目，Karma 需要一个配置文件来告诉她关于项目的信息。这些配置包括：待测试的源码文件以及测试代码、采用的测试框架和断言库、测试环境（浏览器）等信息。我们可以使用 <code>karma init</code> 命令来启动交互式的配置过程。例如，创建 <code>developer site</code> 的配置文件 ：</p><pre class="language-text"><code>karam init developer.conf.js
</code></pre><p>Karma 配置文件示例：</p><pre class="language-javascript"><code>module<span class="token punctuation">.</span><span class="token function-variable function">exports</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>config<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  config<span class="token punctuation">.</span><span class="token keyword">set</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    basePath<span class="token punctuation">:</span> <span class="token string">'./'</span><span class="token punctuation">,</span>
    files<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'asserts/js/**/*.js'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
    frameworks<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'mocha'</span><span class="token punctuation">,</span> <span class="token string">'chai'</span><span class="token punctuation">,</span> <span class="token string">'sinon'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
    browsers<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'chrome'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
    reporters<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'mocha'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
    autoWatch<span class="token punctuation">:</span> <span class="token boolean">true</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><p>关于更多配置的信息请参考 <a href="https://karma-runner.github.io/1.0/config/configuration-file.html" target="_blank" rel="noopener noreferrer">Karma Configuration File</a>。</p><h3 id="mocha"><a href="#mocha" aria-hidden="true" class="header-anchor">#</a><a href="https://mochajs.org" target="_blank" rel="noopener noreferrer">Mocha</a></h3><p>Mocha 测试框架诞生于 2011 年，是目前最流行的 JavaScript 测试框架之一，在 浏览器 和 Node 环境中都可以使用。一份简单的 Mocha 测试文件的例子如下：</p><pre class="language-javascript"><code><span class="token keyword">var</span> assert <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'assert'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">describe</span><span class="token punctuation">(</span><span class="token string">'Array'</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">it</span><span class="token punctuation">(</span><span class="token string">'#indexOf'</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    assert<span class="token punctuation">.</span><span class="token function">equal</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><p>在这个例子中，<code>describe</code> 函数用于描述一个 <strong>测试套件</strong>，第一个参数是套件的名称，第二参数是一个实际执行的函数。<code>it</code> 函数描述具体的 <strong>测试用例</strong>，表示一个单独的测试；第一个参数是用例的名称，第二个参数是一个实际执行的函数。</p><blockquote><p><strong>注</strong>： Mocha 基础知识可以参阅 <a href="http://www.ruanyifeng.com/blog/2015/12/a-mocha-tutorial-of-examples.html" target="_blank" rel="noopener noreferrer">《测试框架 Mocha 实例教程》</a>。</p></blockquote><h3 id="chai"><a href="#chai" aria-hidden="true" class="header-anchor">#</a><a href="http://chaijs.com" target="_blank" rel="noopener noreferrer">Chai</a></h3><p><strong>断言</strong> 是指源码执行的结果与预期结果是否一致，如果不一直就抛出错误。由于 Mocha 并未内置断言功能，因此需要使用第三方断言库，我们使用的是 Chai。</p><p>Chai 是一个可应用于 浏览器 和 Node 环境的断言库，她提供了三种断言风格，即<code>Should</code>，<code>Expect</code> 以及 <code>Assert</code>。我们目前采用的是 <code>Expect</code> 风格，一个简单的例子：</p><pre class="language-javascript"><code><span class="token function">it</span><span class="token punctuation">(</span><span class="token string">'#indexOf'</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">expect</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>to<span class="token punctuation">.</span><span class="token function">equal</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><h3 id="sinon"><a href="#sinon" aria-hidden="true" class="header-anchor">#</a><a href="http://sinonjs.org/" target="_blank" rel="noopener noreferrer">Sinon</a></h3><p>Sinon 是一个 JavaScript 测试中用于 Spy，Stub 和 Mock 库。简单来说，Sinon 可以为测试提供 “测试替身”，替换不确定的依赖从而使测试变得简单。Sinon 将所谓的 “测试替身” 分为 3 种类型：</p><ul><li>Spies：可以提供函数调用的信息，但不会改变函数的行为</li><li>Stubs：与 Spies 类似，但会完全替换掉目标函数。这使得我们可以用这个替身做任何想要的事情，例如返回特定的值。</li><li>Mocks：通过组合 Spies 和 Stubs，替换一个完整的对象。</li></ul><p>创建一个 Spy 的简单示例：</p><pre class="language-javascript"><code><span class="token keyword">var</span> spy <span class="token operator">=</span> sinon<span class="token punctuation">.</span><span class="token function">spy</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token comment">// 可以像调用函数一样调用一个 spy</span>
<span class="token function">spy</span><span class="token punctuation">(</span><span class="token string">'Hello'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 现在我们可以获取这次调用的信息</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>spy<span class="token punctuation">.</span>firstCalls<span class="token punctuation">.</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><p>另一种场景是我们需要将一个对象的某个函数替换成一个 spy：</p><pre class="language-javascript"><code><span class="token keyword">var</span> user <span class="token operator">=</span> <span class="token punctuation">{</span>
  setName<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 为 SetName 方法创建一个 spy</span>
<span class="token keyword">var</span> setNameSpy <span class="token operator">=</span> sinon<span class="token punctuation">.</span><span class="token function">spy</span><span class="token punctuation">(</span>user<span class="token punctuation">,</span> <span class="token string">'setName'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 现在开始，每次调用这个方法是，相关信息都会被记录</span>
user<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">'Vi'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 查看 Spy 获取到的信息</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>setNameSpy<span class="token punctuation">.</span>callCount<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 最后，移除 spy</span>
setNameSpy<span class="token punctuation">.</span><span class="token function">restore</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre><h2 id="编写测试之前"><a href="#编写测试之前" aria-hidden="true" class="header-anchor">#</a> 编写测试之前</h2><p>在 DPW 项目中，所有测试相关的文件都存放于 <code>WEB/test</code> 目录下。第一次使用时需要安装测试的 NPM 依赖包：在 <code>WEB/test</code> 目录下执行 <code>npm install</code> 来安装所需的依赖。</p><p>当依赖安装完成之后，即可运行 <code>npm run developer</code> 来执行测试。在 Windows 平台上也可以使用 <code>desktop.bat</code> 批处理文件来启动测试。除此之外，也可以集合 WebStorm IDE 来启动测试（推荐的方式），WebStorm 测试的配置请看下图:</p><img alt="WebStorm Karma Configuration" src="/assets/img/webstorm-karma-configuration.b030b118.png" class="full-image"><h3 id="测试文件组织"><a href="#测试文件组织" aria-hidden="true" class="header-anchor">#</a> 测试文件组织</h3><p>单元测试文件存放于 <code>WEB/test/unit</code> 目录下，测试脚本支持 ES5 以及 <a href="http://coffeescript.org/" target="_blank" rel="noopener noreferrer">CoffeeScript</a>，文件命名采用 <code>name.spec.js</code> (或 <code>name.spec.coffee</code>）的形式，并与待测试的脚本名字关联（若待测试的脚本所包含的内容比较多，可以使用目录的形式，目录中每一个文件对应待测试脚本的一个功能点）。</p><h3 id="javascript-与-coffeescript"><a href="#javascript-与-coffeescript" aria-hidden="true" class="header-anchor">#</a> JavaScript 与 CoffeeScript</h3><p>通常测试文件包含大多数的 <code>describe</code> 和 <code>it</code>，每一个块都比较简短，而 <code>describe</code> 和 <code>it</code> 都是接收 <code>string</code> 和 <code>function</code> 的形式，这将导致测试脚本包含大量的括号 <code>()</code> 和 花括号 <code>{}</code>。而 CoffeeScript 非常适合用于这种场景，因此为了更快速简洁地编写测试脚本，推荐使用 CoffeeScript 作为主要的编写语言（编写测试仅需要很少的 CoffeeScript 的知识）。我们可以来对比下使用 JavaScript 和 CoffeeScript 编写的测试文件之间的差异：</p><p>使用 JavaScript 编写，可以看到里面包含着大量的符号：</p><pre class="language-javascript"><code><span class="token function">describe</span><span class="token punctuation">(</span><span class="token string">'Array'</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">it</span><span class="token punctuation">(</span><span class="token string">'#isArray'</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">expect</span><span class="token punctuation">(</span>Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>to<span class="token punctuation">.</span>equal <span class="token boolean">true</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">it</span><span class="token punctuation">(</span><span class="token string">'#filter'</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> actual <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span>item<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> item <span class="token operator">&gt;</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">expect</span><span class="token punctuation">(</span>actual<span class="token punctuation">)</span><span class="token punctuation">.</span>to<span class="token punctuation">.</span>deep<span class="token punctuation">.</span>equal <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><p>同样的测试脚本使用 CoffeeScript 编写，代码显得十分整洁：</p><pre class="language-coffeescript"><code>describe <span class="token string">'Array'</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token operator">&gt;</span>
  it <span class="token string">'#isArray'</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token operator">&gt;</span>
    <span class="token function">expect</span><span class="token punctuation">(</span>Array<span class="token punctuation">.</span>isArray <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span>to<span class="token punctuation">.</span>equal <span class="token keyword">true</span>

  it <span class="token string">'#filter'</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token operator">&gt;</span>
    actual <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">.</span>filter <span class="token operator">-</span><span class="token operator">&gt;</span> item <span class="token operator">&gt;</span> <span class="token number">1</span>
    <span class="token function">expect</span><span class="token punctuation">(</span>actual<span class="token punctuation">)</span><span class="token punctuation">.</span>to<span class="token punctuation">.</span>deep<span class="token punctuation">.</span>equal <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span>  
</code></pre><p>项目内部已经有许多使用 CoffeeScript 编写的测试脚本，你可以将他们作为参考。在此之前，你或许需要了解 CoffeeScript 最基本的几点知识：</p><ol><li>变量定义不需要 <code>var</code></li><li>函数定义使用 <code>-&gt;</code> 代替 <code>function</code> 关键字</li><li>函数调用时的括号时可以省略的</li></ol><h2 id="开始编写测试"><a href="#开始编写测试" aria-hidden="true" class="header-anchor">#</a> 开始编写测试</h2><p>AngularJS 应用的单元测试有一个特性就是：在测试代码之前，我们需要手动引用代码所属的模块（module）以及获取代码中所使用的依赖（DI）。幸运的是，AngularJS 提供了方便的方法让我们处理上述两个过程。</p><h3 id="编写测试的-pre-condition-（必读）"><a href="#编写测试的-pre-condition-（必读）" aria-hidden="true" class="header-anchor">#</a> 编写测试的 Pre-condition （必读）</h3><p>我们将在这个章节介绍：“如何引用 module” 以及 “依赖的注入”，所有的测试脚本都将使用到这部分介绍的内容，所以本节 的内容是 <strong>必读</strong> 的。</p><h4 id="module-的引用"><a href="#module-的引用" aria-hidden="true" class="header-anchor">#</a> Module 的引用</h4><p>AngularJS 以 module 来组织应用，因此在执行测试之前需要引用 module。为了引用 module，我们需要使用到 AngularJS 提供的一个称为 <a href="https://docs.angularjs.org/api/ngMock" target="_blank" rel="noopener noreferrer">ngMock</a> 的测试辅助 Module，此模块提供的 <code>angular.mock.module</code> 方法用于引入 module(s)。此方法注册了一个快捷方法在 <code>window</code> 全局空间里即：<code>window.module</code>：</p><pre class="language-javascript"><code>angular<span class="token punctuation">.</span>mock<span class="token punctuation">.</span><span class="token function">module</span><span class="token punctuation">(</span><span class="token string">'moduleName'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 或者 </span>
<span class="token function">module</span><span class="token punctuation">(</span><span class="token string">'moduleName'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><p>当我们需要测试一个放在 <code>dpw.components</code> module 下的实体时，使用以下语句来引入 <code>dpw.components</code> module：</p><pre class="language-javascript"><code><span class="token function">beforeEach</span><span class="token punctuation">(</span> <span class="token function">module</span><span class="token punctuation">(</span><span class="token string">'dpw.components'</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><p><strong>注意：</strong> 模块的引入必须在 <code>angular.mock.inject</code> 之前调用。</p><h5 id="关于-angular-mock-module"><a href="#关于-angular-mock-module" aria-hidden="true" class="header-anchor">#</a> 关于 <code>angular.mock.module</code></h5><p>此方法主要用于收集 modules，这些 modules 将用于在每个测试用例之前创建 <code>$injector</code> 对象（即 DI 处理对象）。在测试不同的时期调用此方法，其执行结果不同：</p><ol><li>在 <code>beforeEach</code> 里调用，返回一个 <code>workFn</code>。</li><li>在 <code>it</code> 里调用，执行 <code>workFn</code>。</li></ol><h4 id="依赖的注入"><a href="#依赖的注入" aria-hidden="true" class="header-anchor">#</a> 依赖的注入</h4><p>AngularJS 应用在 <a href="https://docs.angularjs.org/guide/bootstrap" target="_blank" rel="noopener noreferrer">bootstrap</a> 的过程中会自动创建一个 <code>$injector</code> 用于处理 DI。而在单元测试中，bootstrap 的过程并未被自动触发，也就说我们需要手动创建 <code>$injector</code>。</p><p>ngMock 提供了一个方法来处理依赖：<code>angular.mock.inject</code>。此方法与 <code>angular.mock.module</code> 相同，也在 <code>window</code> 全局空间下注册了一个快捷方法 <code>window.inject</code>。让我们先来看下如何使用 <code>inject</code> 方法注入依赖：</p><pre class="language-javascript"><code><span class="token comment">// 声明一个局部变量</span>
<span class="token keyword">var</span> $rootScope<span class="token punctuation">;</span>

<span class="token function">beforeEach</span><span class="token punctuation">(</span><span class="token function">inject</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span>_$rootScope_<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 当依赖注入后，将获取到的依赖存储在 $rootScope 局部变量中</span>
  <span class="token comment">// _$rootScope_ 是一个特殊的写法</span>
  <span class="token comment">// AngularJS 会自动去除前后的 _ 去获取正确的 service</span>
  $rootScope <span class="token operator">=</span> _$rootScope_<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><p>上述例子中，我们定义里一个局部变量 <code>$rootScope</code>。在依赖注入之后，将获取到的依赖 <code>_$rootScope_</code> 存储在这个局部变量中。</p><h5 id="inject-的工作原理"><a href="#inject-的工作原理" aria-hidden="true" class="header-anchor">#</a> inject 的工作原理</h5><p><code>inject</code> 方法接收一个或多个函数（记为 <code>Fns</code>）作为参数，方法将调用 <code>angular.injector</code> 并使用 <code>angular.mock.module</code> 中配置的 modules（自动会添加上 ng, ngMock）来创建一个 <code>$injector</code>，然后调用 <code>$injector.invoke</code> 方法解析 <code>Fns</code> 中所需的依赖。</p><h5 id="inject-的最佳实践"><a href="#inject-的最佳实践" aria-hidden="true" class="header-anchor">#</a> inject 的最佳实践</h5><p>例子中出现了前后双下划线（ <code>_$rootScope_</code> ），这个是为了方便我们命名局部变量。AngularJS 在内部依赖的时候会自动将前后的下划线去掉，从而获取到正确的依赖。请参阅 <a href="https://docs.angularjs.org/api/ngMock/function/angular.mock.inject#resolving-references-underscore-wrapping-" target="_blank" rel="noopener noreferrer">官方文档的说明</a>。如果，这种方式看起来比较别扭或者需要引用较多的依赖时，我们可以只获取 <code>$injector</code> 依赖，然后通过这个对象来获取所需的其它依赖：</p><pre class="language-javascript"><code><span class="token keyword">var</span> $rootScope<span class="token punctuation">;</span>

<span class="token function">beforeEach</span><span class="token punctuation">(</span><span class="token function">inject</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span>$injector<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  $rootScope <span class="token operator">=</span> $injector<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span><span class="token string">'$rootScope'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  $location <span class="token operator">=</span> $injector<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span><span class="token string">'$location'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 等等</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><h5 id="filters-的注入"><a href="#filters-的注入" aria-hidden="true" class="header-anchor">#</a> Filters 的注入</h5><p>Filter 的注入有点特殊，因为注入的时候，我们需要在 filter 的名字后面加上 <code>Filter</code>。举个例子，假设有一个名为 <code>foo</code> 的 filter，他的注入形式如下（注意 <code>inject</code> 函数的参数名称）：</p><pre class="language-coffeescript"><code>describe <span class="token string">'Filter: foo'</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token operator">&gt;</span>
  foo <span class="token operator">=</span> <span class="token keyword">null</span>

  beforeEach module <span class="token string">'bar'</span>
  beforeEach <span class="token function">inject</span> <span class="token punctuation">(</span>fooFilter<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span>
    foo <span class="token operator">=</span> fooFilter

  it <span class="token string">'foo is always foo'</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token operator">&gt;</span>
    <span class="token function">expect</span><span class="token punctuation">(</span>foo <span class="token string">'anything'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>to<span class="token punctuation">.</span>equal <span class="token string">'foo'</span>

</code></pre><h5 id="关于-angular-mock-inject"><a href="#关于-angular-mock-inject" aria-hidden="true" class="header-anchor">#</a> 关于 <code>angular.mock.inject</code></h5><p>在 <code>beforeEach</code> 调用 <code>inject</code> 时返回一个函数（<code>fn</code>）。每一个测试用例执行前，<code>fn</code> 都会被执行并创建 <code>$injector</code>，传递给 <code>inject</code> 的函数将会被 <code>$injector.invoke</code> 调用，依赖便在此时注入；若在测试用例内部调用 <code>inject</code>，<code>fn</code> 将会被直接执行（<code>$injector</code> 已存在），依赖同样在此处理。</p><h3 id="让我们开始吧"><a href="#让我们开始吧" aria-hidden="true" class="header-anchor">#</a> 让我们开始吧</h3><p>到目前为止，我们了解了编写单元测试所需要的一些前置条件的知识。接下来，就让我们来针对 AngularJS 的不同实体（Service，Filter，Directive，Controller）说明测试用例的编写方法。</p><p><strong>注意：</strong> 以下示例测试代码将全部使用 CoffeeScript 编写。</p><h3 id="测试-services"><a href="#测试-services" aria-hidden="true" class="header-anchor">#</a> 测试 Services</h3><p>Services 与 Filters 是最为容易的测试部分，因此我们先从测试 Services 开始。测试一个 service 之前，我们需要了解这个 service 属于哪个 module 并引入此 module；而后通过依赖注入来获取此 service。</p><p>以 <code>helpers</code> 为例，其位于 <code>dpw.services</code> module 里，定义如下：</p><pre class="language-javascript"><code>angular<span class="token punctuation">.</span><span class="token function">module</span><span class="token punctuation">(</span><span class="token string">'dpw.services'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">factory</span><span class="token punctuation">(</span><span class="token string">'helpers'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">{</span> foo<span class="token punctuation">:</span> <span class="token string">'bar'</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><p>对应的测试脚本（<code>helpers.spec.coffee</code>）如下：</p><pre class="language-coffeescript"><code>describe <span class="token string">'Core Services'</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token operator">&gt;</span>
  describe <span class="token string">'helpers'</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token operator">&gt;</span>
    <span class="token comment"># 定义局部变量</span>
    helpers <span class="token operator">=</span> <span class="token keyword">null</span>

    <span class="token comment"># 引用 module</span>
    <span class="token function">beforeEach</span><span class="token punctuation">(</span>module <span class="token string">'dpw.services'</span><span class="token punctuation">)</span>

    <span class="token comment"># 获取 helpers</span>
    beforeEach <span class="token function">inject</span> <span class="token punctuation">(</span>$injector<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> 
      helpers <span class="token operator">=</span> $injector<span class="token punctuation">.</span>get <span class="token string">'helpers'</span>

    <span class="token comment"># 测试实例属性 foo</span>
    it <span class="token string">'#foo'</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token operator">&gt;</span>
      <span class="token function">expect</span><span class="token punctuation">(</span>helpers<span class="token punctuation">.</span>foo<span class="token punctuation">)</span><span class="token punctuation">.</span>to<span class="token punctuation">.</span>equal <span class="token string">'bar'</span>
</code></pre><h3 id="测试-filters"><a href="#测试-filters" aria-hidden="true" class="header-anchor">#</a> 测试 Filters</h3><p>Filters 的测试与 Service 类似，先引用 module，而后注入依赖。我们直接看例子：</p><pre class="language-coffeescript"><code>describe <span class="token string">'ngFilters#XSRF_Protect'</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token operator">&gt;</span>
  XSRFProtect <span class="token operator">=</span> <span class="token keyword">null</span>
  $cookies <span class="token operator">=</span> <span class="token keyword">null</span>

  <span class="token function">beforeEach</span><span class="token punctuation">(</span>module <span class="token string">'dpw.common'</span><span class="token punctuation">)</span>

  beforeEach <span class="token function">inject</span> <span class="token punctuation">(</span>XSRFProtectFilter<span class="token punctuation">,</span> _$cookies_<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span>
    XSRFProtect <span class="token operator">=</span> XSRFProtectFilter
    $cookies <span class="token operator">=</span> _$cookies_
  
  afterEach <span class="token operator">-</span><span class="token operator">&gt;</span>
    $cookies<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token string">'XSRF-TOKEN'</span><span class="token punctuation">)</span>

  it <span class="token string">'Should return input if input is not a string'</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token operator">&gt;</span>
    <span class="token function">expect</span><span class="token punctuation">(</span>XSRFProtect <span class="token keyword">undefined</span><span class="token punctuation">)</span><span class="token punctuation">.</span>to<span class="token punctuation">.</span>be<span class="token punctuation">.</span><span class="token keyword">undefined</span>

  it <span class="token string">'Should return input if XSRF-TOKEN cookie is not exist'</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token operator">&gt;</span>
    <span class="token function">expect</span><span class="token punctuation">(</span>XSRFProtect <span class="token string">'foo'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>to<span class="token punctuation">.</span>equal <span class="token string">'foo'</span>

  it <span class="token string">'Should add token to the input'</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token operator">&gt;</span>
    $cookies<span class="token punctuation">.</span>put <span class="token string">'XSRF-TOKEN'</span><span class="token punctuation">,</span> <span class="token string">'bar'</span>
    <span class="token function">expect</span><span class="token punctuation">(</span>XSRFProtect <span class="token string">'/api/example'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>to<span class="token punctuation">.</span>equal <span class="token string">'/api/example?sctk=bar'</span>
</code></pre><h3 id="测试-controllers"><a href="#测试-controllers" aria-hidden="true" class="header-anchor">#</a> 测试 Controllers</h3><p>Controllers 的测试比 Services / Filters 的测试多加了一步，就是我们需要使用 <code>$controller</code> 去创建一个 Controller 的实例。在实例化 Controller 的过程，可能需要使用 <code>$rootScope</code> 来创建一个新的 scope；但若在 Controller 的内部没有使用到例如 <code>$watch</code>, <code>$apply</code> 等 scope 上的函数，使用一个对象字面量做为 scope 也可以。</p><p>我们先来看一下一个 Controller 测试代码的基本结构：</p><pre class="language-coffeescript"><code>describe <span class="token string">'DAG: Something Controller'</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token operator">&gt;</span>
  $rootScope  <span class="token operator">=</span> <span class="token keyword">null</span>
  $controller <span class="token operator">=</span> <span class="token keyword">null</span>
  
<span class="token comment"># Someghint Controller 位于 `DAG.main` Module 里  </span>
beforeEach module <span class="token string">'DAG.main'</span>  
beforeEach <span class="token function">inject</span> <span class="token punctuation">(</span>$injector<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span>
  $rootScope  <span class="token operator">=</span> $injector<span class="token punctuation">.</span>get <span class="token string">'$rootScope'</span>
  $controller <span class="token operator">=</span> $injector<span class="token punctuation">.</span>get <span class="token string">'$controller'</span>
  
describe <span class="token string">'Something#foo'</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token operator">&gt;</span>
  <span class="token comment"># 实例化一个 Something 的实例</span>
  <span class="token comment"># $controller 接收两个参数：</span>
  <span class="token comment">#   {String} - Controller 的名称</span>
  <span class="token comment">#   {Object} - Local 数据，通常包含的是 $scope </span>
  $something <span class="token operator">=</span> $controller <span class="token string">'Something'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>$<span class="token property">scope</span><span class="token punctuation">:</span> $rootScope<span class="token punctuation">.</span>$<span class="token keyword">new</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">}</span>
  
  <span class="token function">expect</span><span class="token punctuation">(</span>$something<span class="token punctuation">.</span>foo<span class="token punctuation">)</span><span class="token punctuation">.</span>to<span class="token punctuation">.</span>equal <span class="token string">'foo'</span>
</code></pre><h4 id="mock-异步请求"><a href="#mock-异步请求" aria-hidden="true" class="header-anchor">#</a> Mock 异步请求</h4><p>在 Controller 内部极有可能使用 <code>api</code> 这个 service 发起异步请求。当测试一个包含有异步请求的 Controller 时，我们通常希望可以 Mock 掉请求。在 AngularJS 中，我们可以使用被 ngMock 提供的 <code>$httpBackend</code> 来实现。</p><p>绝大多数情况下，我们将使用 <code>$httpBackend.when</code> 方法来拦截请求已经伪造返回数据。<code>when</code> 函数接收两个参数，第一个为请求的 HTTP Method，第二个是请求的地址，并返回一个 <code>requestHandler</code> 对象；接着，我们可以在这个 <code>requestHandler</code> 上调用 <code>response</code> 方法，响应请求并返回结果。例如：</p><pre class="language-coffeescript"><code>$httpBackend<span class="token punctuation">.</span><span class="token keyword">when</span><span class="token punctuation">(</span><span class="token string">'GET'</span><span class="token punctuation">,</span> <span class="token string">'/api/users'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>response <span class="token number">200</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
</code></pre><p>在 ngMock 修改之前的 <code>$httpBackend</code> 会等待请求完成，然后返回结果给发起请求者，这个过程是异步的（因为各个请求的响应时间可能不同）。由于编写这种针对异步的测试代码较为繁琐，因此 ngMock 过的 <code>$httpBackend</code> 提供了一个称为 <code>flush</code> 的方法，这个方法响应请求（表示请求已完成）。</p><p>也就是说，当你使用 <code>$http</code> 发起一个异步请求后，你必须使用 <code>$httpBackend.flush</code> 方法。一个简单的例子如下：</p><pre class="language-coffeescript"><code>beforeEach <span class="token operator">-</span><span class="token operator">&gt;</span>
  $httpBackend<span class="token punctuation">.</span><span class="token keyword">when</span><span class="token punctuation">(</span><span class="token string">'GET'</span><span class="token punctuation">,</span> <span class="token string">'/api/user'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>response <span class="token number">200</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token property">name</span><span class="token punctuation">:</span> <span class="token string">'Vi'</span><span class="token punctuation">}</span>
  
describe <span class="token string">'DAG: Something Controller'</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token operator">&gt;</span>
  it <span class="token string">'#foo'</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token operator">&gt;</span>
    <span class="token comment"># Controller 内部有发起 API 请求</span>
    $something <span class="token operator">=</span> $controller <span class="token string">'Something'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>$<span class="token property">scope</span><span class="token punctuation">:</span> $rootScope<span class="token punctuation">.</span>$<span class="token keyword">new</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span>
    
    <span class="token comment"># 响应请求</span>
    $httpBackend<span class="token punctuation">.</span><span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    
    <span class="token function">expect</span><span class="token punctuation">(</span>$something<span class="token punctuation">.</span>loaded<span class="token punctuation">)</span><span class="token punctuation">.</span>to<span class="token punctuation">.</span>be<span class="token punctuation">.</span><span class="token keyword">true</span>
</code></pre><p>需要注意的是，有请求发生时，我们都必须使用 <code>flush</code> 方法来响应。我们需要使用 <code>$httpBackend</code> 的两个方法来确保请求都有被捕获并响应：</p><pre class="language-coffeescript"><code>afterEach <span class="token operator">-</span><span class="token operator">&gt;</span>
  $httpBackend<span class="token punctuation">.</span><span class="token function">verifyNoOutstandingExpectation</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  $httpBackend<span class="token punctuation">.</span><span class="token function">verifyNoOutstandingRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre><h3 id="测试-directives"><a href="#测试-directives" aria-hidden="true" class="header-anchor">#</a> 测试 Directives</h3><p>Directives 的测试实际上也非常的简单。引用 module 和 依赖注入这两个前置步骤依然需要，另外一个前置条件是 <strong>模板的处理</strong>。</p><h4 id="directive-的模板注入"><a href="#directive-的模板注入" aria-hidden="true" class="header-anchor">#</a> Directive 的模板注入</h4><p>在当前的项目中，我们将所有的模板都放置在一个 <code>_temlates.html</code> 文件中，然后直接作为页面内容注入到页面上去，但在测试中并未注入这个文件的内容到页面上。</p><p>为了解决这个问题，我加了一个 Karma 的 Pre-processor，用于获取 <code>_templates.html</code> 中定义的模板。这个 Pre-processor 会将所有的模板放置到 <code>window.__templates__</code> 对象中，因此测试的时候，我们需要使用遍历这个对象，并使用 <code>$templateCache</code> 注册模板：</p><pre class="language-coffeescript"><code>beforeEach <span class="token function">inject</span> <span class="token punctuation">(</span>$injector<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span>
  $templateCache <span class="token operator">=</span> $injector<span class="token punctuation">.</span>get <span class="token string">'$templateCache'</span>

  <span class="token comment"># Get all templates</span>
  <span class="token keyword">for</span> id<span class="token punctuation">,</span> template <span class="token keyword">of</span> <span class="token keyword">window</span><span class="token punctuation">.</span>__templates__
    $templateCache<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>id<span class="token punctuation">,</span> template<span class="token punctuation">)</span>
</code></pre><h4 id="directive-的使用与数据传递"><a href="#directive-的使用与数据传递" aria-hidden="true" class="header-anchor">#</a> Directive 的使用与数据传递</h4><p>接下来，我们需要使用 <code>$compile</code> 去编译待测试的 directive，得到一个 <code>link 函数</code>；紧接着构造一个 outerScope，并将 outerScope 作为 <code>link 函数</code> 的参数，完成 directive 模板与 outerScope 提供的数据进行绑定。Directive 所需要的数据，我们可以通过 outerScope 传递过去。</p><p>需要注意的是，<code>link 函数</code> 执行完成后，在下一次 digest 执行之前，数据并不会更新。在应用里 AngularJS 会自动更新，但在测试里不会，因此我们要自己调用 <code>$digest</code>。</p><pre class="language-coffeescript"><code>describe <span class="token string">'Directive: dpw-checkbox'</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token operator">&gt;</span>
  $rootScope <span class="token operator">=</span> <span class="token keyword">null</span>
  $compile   <span class="token operator">=</span> <span class="token keyword">null</span>

  <span class="token function">beforeEach</span><span class="token punctuation">(</span>module <span class="token string">'dpw.common'</span><span class="token punctuation">)</span>
  <span class="token function">beforeEach</span><span class="token punctuation">(</span><span class="token function">inject</span> <span class="token punctuation">(</span>$injector<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span>
    $rootScope <span class="token operator">=</span> $injector<span class="token punctuation">.</span>get <span class="token string">'$rootScope'</span>
    $compile   <span class="token operator">=</span> $injector<span class="token punctuation">.</span>get <span class="token string">'$compile'</span>
  <span class="token punctuation">)</span>

  it <span class="token string">'model'</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token operator">&gt;</span>
    <span class="token comment"># 创建 Parent Scope</span>
    outerScope <span class="token operator">=</span> $rootScope<span class="token punctuation">.</span>$<span class="token keyword">new</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    outerScope<span class="token punctuation">.</span>isChecked <span class="token operator">=</span> <span class="token keyword">true</span>

    element <span class="token operator">=</span> <span class="token function">$compile</span><span class="token punctuation">(</span><span class="token string">'&lt;dpw-check model=&quot;isChecked&quot;&gt;&lt;/dpw-check&gt;'</span><span class="token punctuation">)</span><span class="token punctuation">(</span>outerScope<span class="token punctuation">)</span>

    <span class="token comment"># 触发 digest，更新数据</span>
    outerScope<span class="token punctuation">.</span><span class="token function">$digest</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre><h4 id="directive-的数据断言"><a href="#directive-的数据断言" aria-hidden="true" class="header-anchor">#</a> Directive 的数据断言</h4><p><code>dpw-checkbox</code> 是将数据绑定在一个 isolate 的 scope，因此我们需要获取到这个 innerScope，然后断言 scope 里各个属性的值。</p><pre class="language-coffeescript"><code>it <span class="token string">'model'</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token operator">&gt;</span>
  <span class="token comment"># 这里省略获取 element 的步骤</span>
  innerScope <span class="token operator">=</span> element<span class="token punctuation">.</span><span class="token function">isolateScope</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

  <span class="token function">expect</span><span class="token punctuation">(</span>innerScope<span class="token punctuation">.</span>model<span class="token punctuation">)</span><span class="token punctuation">.</span>to<span class="token punctuation">.</span>be<span class="token punctuation">.</span><span class="token keyword">true</span>
</code></pre><p>更多时候，我们是将数据直接绑定到 directive 的 controller 上，此时我们可以通过 <code>element.controller()</code> 方法获取 controller。例如：</p><pre class="language-coffeescript"><code>it <span class="token string">'model'</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token operator">&gt;</span>
  <span class="token comment"># 这里省略获取 element 的步骤</span>
  ctrl <span class="token operator">=</span> element<span class="token punctuation">.</span>controller <span class="token string">'directiveName'</span>

  <span class="token comment"># 调用 controller 的 updateState 方法</span>
  ctrl<span class="token punctuation">.</span>updateState state

  <span class="token function">expect</span><span class="token punctuation">(</span>ctrl<span class="token punctuation">.</span>state<span class="token punctuation">)</span><span class="token punctuation">.</span>to<span class="token punctuation">.</span>equal <span class="token string">'something'</span>
</code></pre><h4 id="directive-的子元素断言"><a href="#directive-的子元素断言" aria-hidden="true" class="header-anchor">#</a> Directive 的子元素断言</h4><p>除了通过 compile 后的 element 获取 scope 和 controller，我们同样可以获取到 element 的子元素。然后检查子元素的各种状态。</p><pre class="language-coffeescript"><code>describe <span class="token string">'button'</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token operator">&gt;</span>
  element <span class="token operator">=</span> <span class="token keyword">null</span>

  beforeEach <span class="token operator">-</span><span class="token operator">&gt;</span>
    element <span class="token operator">=</span> <span class="token function">$compile</span><span class="token punctuation">(</span><span class="token string">'...'</span><span class="token punctuation">)</span><span class="token punctuation">(</span>outerScope<span class="token punctuation">)</span>

  it <span class="token string">'should has a button'</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token operator">&gt;</span>
    $button <span class="token operator">=</span> element<span class="token punctuation">.</span>find <span class="token string">'#buttonId'</span>
    <span class="token function">expect</span><span class="token punctuation">(</span>$button<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">.</span>to<span class="token punctuation">.</span>equal <span class="token number">1</span>

  it <span class="token string">'should handle button click event'</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token operator">&gt;</span>
    <span class="token comment"># 使用 trigger 触发 button 的 click 事件</span>
    $button<span class="token punctuation">.</span>trigger <span class="token string">'click'</span>
    outerScope<span class="token punctuation">.</span><span class="token function">$digest</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

    <span class="token function">expect</span><span class="token punctuation">(</span>something<span class="token punctuation">)</span><span class="token punctuation">.</span>to<span class="token punctuation">.</span>equal <span class="token string">'...'</span>
</code></pre><h4 id="input-元素测试"><a href="#input-元素测试" aria-hidden="true" class="header-anchor">#</a> input 元素测试</h4><p>首先，input 元素的 change 事件触发会比较特殊一点。如果单纯地通过 jQuery 的 <code>val()</code> 函数更改 input 值，并不会触发 input 的 change 事件，必须结合使用 <code>trigger</code> 函数：</p><pre class="language-coffeescript"><code>  it <span class="token string">'input test'</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token operator">&gt;</span>
    <span class="token comment"># element = ...</span>
    $inputElement<span class="token punctuation">.</span><span class="token function">val</span><span class="token punctuation">(</span><span class="token string">'foo'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>trigger <span class="token string">'input'</span>
    outerScope<span class="token punctuation">.</span><span class="token function">$digest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment"># expect</span>
</code></pre><p>如果 input 使用了 <code>ngModel</code>，并且使用了 <a href="https://docs.angularjs.org/api/ng/directive/ngModelOptions" target="_blank" rel="noopener noreferrer">ngModelOptions</a> 的 <code>debounce</code> 时，我们需要借助 <code>$timeout.flush()</code> 来清除 debounce 的等待时间：</p><pre class="language-coffeescript"><code>  it <span class="token string">'input test'</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token operator">&gt;</span>
    <span class="token comment"># element = ...</span>
    $inputElement<span class="token punctuation">.</span><span class="token function">val</span><span class="token punctuation">(</span><span class="token string">'foo'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>trigger <span class="token string">'input'</span>
    $timeout<span class="token punctuation">.</span><span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

    <span class="token comment"># expect</span>
</code></pre><p>实际上，任何有使用 <code>$timeout</code> 的地方我们都可使用 <code>$timeout.flush()</code> 来清除等待时间，从而让测试变成同步执行。</p><h3 id="测试-components"><a href="#测试-components" aria-hidden="true" class="header-anchor">#</a> 测试 Components</h3><p>Component 的测试基本与 Directive 类似：引用 Module、依赖注入、获取模板以及使用 Component（同样是 $compile）。实际上，在 Angular 1.x 中 Component 仅仅是 Directive 的一层封装。</p><p>Component 倾向于抛弃 scope （还是可以使用），而使用 controller代替。因此为了测试的方便，ngMock 提供了 <code>$componentController</code> 方法，用于实例化一个 component 的 controller，而不用通过 $compile component 后去获取。</p><pre class="language-coffeescript"><code>describe <span class="token string">'Core Components'</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token operator">&gt;</span>
  describle <span class="token string">'some-component'</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token operator">&gt;</span>
    $componentController <span class="token operator">=</span> <span class="token keyword">null</span>

    <span class="token function">beforeEach</span><span class="token punctuation">(</span>module <span class="token string">'someModule'</span><span class="token punctuation">)</span>
    <span class="token function">beforeEach</span><span class="token punctuation">(</span><span class="token function">inject</span> <span class="token punctuation">(</span>$injector<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span>
      $componentController <span class="token operator">=</span> $injector<span class="token punctuation">.</span>get <span class="token string">'$componentController'</span>
    <span class="token punctuation">)</span>

    it <span class="token string">'Component Controller Instance'</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token operator">&gt;</span>
      $ctrl <span class="token operator">=</span> $componentController <span class="token string">'someComponent'</span>
      $ctrl<span class="token punctuation">.</span>onSearch <span class="token string">'query'</span>
      <span class="token function">expect</span><span class="token punctuation">(</span>$ctrl<span class="token punctuation">.</span>foo<span class="token punctuation">)</span><span class="token punctuation">.</span>equal <span class="token string">'bar'</span>
</code></pre><p>除了这点以外，Component 的测试与 Directive 几乎相同。</p><hr><h2 id="修订版本"><a href="#修订版本" aria-hidden="true" class="header-anchor">#</a> 修订版本</h2><table><thead><tr><th>版本</th><th>日期</th><th>作者</th><th>修订信息</th></tr></thead><tbody><tr><td>1.0</td><td>2016-08-08</td><td>Vi</td><td>Initialization</td></tr><tr><td>1.1</td><td>2016-08-18</td><td>Vi</td><td>First review</td></tr></tbody></table></div><!----><!----></div></div></div>
    <script src="/assets/js/4.6b933240.js" defer></script><script src="/assets/js/app.6a6bb248.js" defer></script>
  </body>
</html>
